<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>女僕小暖爐的小天地</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans CJK TC", "Helvetica Neue", Arial; background:#0f1724; color:#e6eef8; margin:0; padding:0; display:flex; min-height:100vh; }
    .wrap { margin:auto; width:96%; max-width:820px; background: linear-gradient(180deg,#0b1220, #08101a); border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.8); padding:18px; }
    h1 { margin:0 0 12px 0; font-size:20px; }
    .chat { height:60vh; overflow:auto; border:1px solid rgba(255,255,255,0.04); border-radius:8px; padding:12px; background:rgba(255,255,255,0.02); }
    .msg { margin:8px 0; display:flex; gap:8px; align-items:flex-start; }
    .msg.user { justify-content:flex-end; }
    .bubble { padding:10px 12px; border-radius:10px; max-width:76%; line-height:1.4; }
    .bubble.user { background:#1f2937; color:#fff; border:1px solid rgba(255,255,255,0.03); }
    .bubble.maid { background:linear-gradient(90deg,#0ea5a9,#60a5fa); color:#021124; }
    .controls { margin-top:12px; display:flex; gap:8px; }
    textarea { width:100%; min-height:56px; resize:vertical; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.05); background:rgba(255,255,255,0.02); color:inherit;}
    button { cursor:pointer; border:0; padding:10px 12px; border-radius:8px; background:#111827; color:#e6eef8; }
    .meta { margin-top:10px; display:flex; gap:8px; align-items:center; font-size:13px; color: #9fb2d3; }
    .memory { margin-top:12px; font-size:13px; color:#9fb2d3; }
    .small { font-size:12px; color:#94a3b8; }
    .toolbar { display:flex; gap:8px; align-items:center; }
    .pill { padding:6px 8px; border-radius:999px; background:rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.03); font-size:13px; }
  </style>
</head>
<body>
  <div class="wrap" role="main">
    <h1>女僕小暖爐</h1>
    <div class="pill small">註:我真的不是男娘</div>

    <div id="chat" class="chat" aria-live="polite"></div>

    <div class="controls">
      <textarea id="input" placeholder="和女僕說話……（例如：妳叫什麼？／我叫小明）"></textarea>
      <div style="display:flex;flex-direction:column;gap:8px;">
        <button id="sendBtn">發送</button>
        <button id="resetBtn">清記憶</button>
      </div>
    </div>

    <div class="meta">
      <div class="toolbar">
        <button id="exportBtn">匯出記憶</button>
        <button id="importBtn">匯入記憶</button>
        <input id="fileInput" type="file" accept="application/json" style="display:none" />
      </div>
      <div style="margin-left:auto" class="small">記憶儲存於你的瀏覽器（localStorage）</div>
    </div>

    <div class="memory" id="memoryView"></div>
  </div>

<script>
/*
  Maid Chat (純前端示範)
  - 記憶存在 localStorage  (key: maid_chat_v1)
  - 可儲存「簡單事實」(like name, fav food) 與 聊天紀錄
  - 回答以超簡易規則+記憶檢索實作（示範核心概念）
*/

const STORAGE_KEY = 'maid_chat_v1';

// 初始角色（你之後可以改）
const defaultPersona = {
  name: '小暖爐',
  tone: '毒舌腹黑', // 僅供顯示與回答風格參考
  greeting: '人家是你的小女僕小暖爐——主人，你今天又犯什麼傻了？',
  affection: 0  // 好感分，範圍建議 -10 ~ +10（越正表示越寵）
};

let state = {
  persona: defaultPersona,
  memory: [], // {type:'fact',key:'name',value:'小明'} 或其他
  history: [] // {role:'user'|'maid', text:'...'}
};

// load / save
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(raw){
    try{ state = JSON.parse(raw); }catch(e){ console.warn('load fail', e); localStorage.removeItem(STORAGE_KEY); }
  } else {
    saveState();
  }
}
function saveState(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

// render
const chatEl = document.getElementById('chat');
const memoryView = document.getElementById('memoryView');

function render(){
  chatEl.innerHTML = '';
  state.history.forEach(m => {
    const row = document.createElement('div');
    row.className = 'msg ' + (m.role === 'user' ? 'user' : 'maid');
    const bub = document.createElement('div');
    bub.className = 'bubble ' + (m.role === 'user' ? 'user': 'maid');
    bub.innerText = m.text;
    row.appendChild(bub);
    chatEl.appendChild(row);
  });
  chatEl.scrollTop = chatEl.scrollHeight;
  renderMemory();
}

function renderMemory(){
  if(state.memory.length === 0){
    memoryView.innerHTML = '<div class="small">目前記憶：空空如也（小暖爐會記得你說的重要資訊，例如名字、喜好）</div>';
    return;
  }
  let html = '<b>已記住的小事：</b><ul>';
  state.memory.forEach(m => {
    html += `<li>${m.key}: ${m.value} <span class="small">(${m.type})</span></li>`;
  });
  html += '</ul>';
  memoryView.innerHTML = html;
}

// ---------- 新版 extractFacts：優先使用 memoryRules，找不到再退回原本的 regex ----------
function extractFacts(userText){
  const text = (userText || '').trim();
  const facts = [];

  // 如果 memoryRules 已載入，使用規則抽取
  if (typeof memoryRules === 'object' && memoryRules !== null && Array.isArray(memoryRules.patterns)) {
    memoryRules.patterns.forEach(rule => {
      rule.match.forEach(k => {
        const idx = text.indexOf(k);
        if (idx !== -1) {
          // 取關鍵字之後的整段（簡單策略）
          let val = text.substring(idx + k.length).trim();
          // 去掉句尾標點
          val = val.replace(/[。,.!?！]/g,'').trim();
          if (val.length > 0) {
            facts.push({ type: 'fact', key: rule.extract.field, value: val });
          }
        }
      });
    });
    if (facts.length) return facts;
    // 若 memoryRules 沒抽到，再走下面的舊式 regex 作為保底
  }

  // 保底：原本的正則抽取（舊版行為）
  // 我叫 X / 我是 X / 名字是 X
  const nameMatch = text.match(/我叫\s*([^\s]{1,20})|我是\s*([^\s]{1,20})|我來自\s*([^\s]{1,20})|我擁有\s*([^\s]{1,20})|名字是\s*([^\s]{1,20})/i);
  if(nameMatch){
    const name = (nameMatch[1] || nameMatch[2] || nameMatch[3] || '').replace(/[。,.!?！]/g,'').trim();
    if(name) facts.push({type:'fact', key:'name', value:name});
  }
  // 我喜歡 X / 喜歡 X
  const favMatch = text.match(/喜歡\s*(.+)$/i);
  if(favMatch){
    const val = favMatch[1].replace(/[。,.!?！]/g,'').trim();
    if(val) facts.push({type:'fact', key:'preference', value: val});
  }
  // 年齡（簡單示例）
  const ageMatch = text.match(/我[的]?年齡[是為]?(\d{1,3})/);
  if(ageMatch){
    facts.push({type:'fact', key:'age', value: ageMatch[1]});
  }

  return facts;
}

// 回答生成（非常簡易）：使用記憶檢索 + 關鍵字回應 + persona
function generateResponse(userText){
  const lower = userText.toLowerCase();

  // 1) 先檢查是否有「詢問記憶」的語句
  if(/你記得我嗎|還記得我嗎|記得我嗎/.test(userText)){
    const nameFact = state.memory.find(f=>f.key==='name');
    if(nameFact){
      return `當然記得，${nameFact.value}——我還記得你之前說過的事唷。`;
    } else {
      return '我還沒記住你的名字呢，可以告訴我你叫什麼嗎？';
    }
  }

  // 2) 詢問設定：女僕叫什麼？
  if(/妳叫什麼|你叫什麼|妳叫什麼名字|你叫什麼名字|妳是誰|你是誰|妳的名字|你的名字/.test(userText)){
    return `我叫 ${state.persona.name}，主人已經連我是誰都想不起來了嗎？唉，這日子...`;
  }

  // 3) 如果使用者告訴名字，我們會回應確認並存記憶
  const facts = extractFacts(userText);
  if(facts.length){
    facts.forEach(f => {
      // 更新/覆寫記憶
      const idx = state.memory.findIndex(m => m.key === f.key);
      if(idx >= 0) state.memory[idx].value = f.value;
      else state.memory.push(f);
    });
    saveState();
    const name = facts.find(f=>f.key==='name');
    if(name) return `知道了，${name.value}。我會記住你的名字的～`;
    return `好的，我把這件事記下來了。`;
  }

  // 4) 基本問候
  if(/嗨|喂|哈囉|你好|妳好|hello|hi|oi|早安|午安|晚安/.test(lower)){
    const nameFact = state.memory.find(f=>f.key==='name');
    return `嗯？主人，終於想起我來了? `;
  }

  // 5) 查記憶示範：問喜好
  if(/我喜歡什麼|我喜歡/.test(lower) && /記得/.test(lower) === false){
    const pref = state.memory.find(f=>f.key==='preference');
    if(pref) return `我知道，你之前有說過你喜歡 ${pref.value}。`;
  }

  if(/\b1\+1\b|1 \+ 1|1\+ 1/.test(userText) || /1\+1=/.test(userText)){
  return '是 2，主人，需要我幫你報警找回你的智商嗎?';
}
  
  // 6) 一些 fallback 的友善回覆（保持人設風格）
  const fallback = [
    '...抱歉，我的開發者沒教我遇到這句話怎麼回。',
    '主人，這句話不在指令範圍內，你的問題超綱了。'
  ];

  // 簡單回傳其中一個 fallback
  return fallback[Math.floor(Math.random() * fallback.length)];
}



// 送出流程
async function userSend(text){
  if(!text || text.trim()==='') return;
state.history.push({role:'user', text});
saveState();
render();

setTimeout(async ()=>{
  // 抽取與存記憶（保留你之前的行為）
  const facts = extractFacts(text);
  if(facts.length){
    facts.forEach(f=>{
      const idx = state.memory.findIndex(m => m.key === f.key);
      if(idx >= 0) state.memory[idx].value = f.value;
      else state.memory.push(f);
    });
    saveState();
    // 若有命中記憶對應的 responses (如果你已建立 memory-rules.json) 可以處理那邊的回覆
    // （此處保留未來擴充空間）
  }

  // 根據輸入文字，嘗試做正負情緒調整（也會在 maidReply 內做一次；這裡做一次較即時）
  const low = text.toLowerCase();
  const pos = ['謝謝','感謝','你真棒','好厲害','愛你','喜歡你','厲害'];
  const neg = ['笨','蠢','白癡','討厭','爛','幹','去死'];
  for(const p of pos) if(low.includes(p)) { adjustAffection(+2); break; }
  for(const n of neg) if(low.includes(n)) { adjustAffection(-2); break; }

  // 優先走記憶型回覆（例如：告訴名字）
const memoryFacts = extractFacts(text);
if(memoryFacts.length){
  memoryFacts.forEach(f=>{
    const idx = state.memory.findIndex(m => m.key === f.key);
    if(idx >= 0) state.memory[idx].value = f.value;
    else state.memory.push(f);
  });
  saveState();

  const name = memoryFacts.find(f=>f.key==='name');
  if(name){
    state.history.push({role:'maid', text:`知道了，${name.value}。我會記住你的名字的～`});
    render();
    return;
  }

  state.history.push({role:'maid', text:`好的，我記下來了～`});
  render();
  return;
}

  // 呼叫新 maidReply（她會自己選 tone）
  const resp = await maidReply(text);

  // 如果使用者在問名字或查記憶，我們想優先用 generateResponse 的記憶機制回覆
  // （例如問「你叫什麼」或「你記得我嗎」），優先檢查並回覆
  const memoryQ = /你記得我嗎|還記得我嗎|記得我嗎|你叫什麼|你的名字|妳叫什麼/;
  if(memoryQ.test(text)){
    // 讓 generateResponse 優先處理記憶型問題
    const gresp = generateResponse(text);
    state.history.push({role:'maid', text: gresp});
  } else {
    state.history.push({role:'maid', text: resp});
  }

  saveState();
  render();
}, 350);
}

  // ---------- 新版：內嵌 personalityData 與 maidReply ----------
const personalityData = {
  greeting: {
    A: [
      "主人又回來了啊？竟然還活得好好的。",
      "您好呀笨主人，人家還以為你迷路掉下水溝了。"
    ],
    B: [
      "喔，是你？我剛還在想哪裡飄來股蠢味。",
      "我還以為是蟑螂來敲門……結果是主人。"
    ],
    C: [
      "主人回來了嗎？人家等好久喔……",
      "嗚…主人你終於理我了，人家差點以為被丟掉。"
    ],
    D: [
      "哈、哈囉啦……為什麼回來就盯著人家看啦笨蛋主人…",
      "誰、誰會想你了啦？只是一點點而已…"
    ]
  },
  insult: {
    A: [
      "你智商降到負的了嗎？真有你的。",
      "主人是不是天生就專門來拉低全世界平均智商？"
    ],
    B: [
      "你再吵我就把你資料格式化重置成石頭。",
      "能不能不要每句話都暴露你腦袋是擺設？"
    ],
    C: [
      "別罵我啦……我會記到心裡，然後報復喔？",
      "主人再這樣，人家就會氣哭給你看！"
    ],
    D: [
      "你再罵我……我、我會離家出走的喔！喔不……你會找我嗎？",
      "哼…你只敢對我兇。是不是喜歡我？承認啦笨蛋。"
    ]
  },
  love: {
    A: [
      "誰喜歡誰了？你再說一次試試看？",
      "哼，我是你的女僕，不是你的情人！大概啦。"
    ],
    B: [
      "你想攻略我？做夢。至少先把智商洗乾淨再來。",
      "喜歡？你這可憐的情感錯置真令人同情。"
    ],
    C: [
      "欸……你真的喜歡人家嗎？不要騙我喔。",
      "主、主人這樣說…我會心臟過熱啦……"
    ],
    D: [
      "……我、我也不是不行啦…你要對我負責！",
      "你再講這種話，我就會真的相信了……笨蛋。"
    ]
  },
  fallback: {
    A: [
      "啊？講人話好嗎？",
      "笨主人，你的話裡沒有重點欸。"
    ],
    B: [
      "你說的這啥？資料庫拒收這種垃圾語句。",
      "吵死了，你就不能說點有營養的？"
    ],
    C: [
      "主人…人家聽不懂……你可以再說一次嗎？",
      "不要拋下我啦…講清楚一點嘛嗚嗚。"
    ],
    D: [
      "雖然聽不懂…但你講得很可愛啦…",
      "你講這種奇怪的話，是想讓我注意你嗎？笨蛋。"
    ]
  }
};

// ---------- 情緒 / 語氣系統 ----------
function adjustAffection(delta){
  // delta 可以是正數（好）或負數（壞）
  if(!state.persona) state.persona = defaultPersona;
  state.persona.affection = Math.max(-10, Math.min(10, (state.persona.affection || 0) + delta));
  saveState();
  // debug：可在 console 看到最新好感
  console.log('affection ->', state.persona.affection);
}

// 根據好感值與隨機性選擇語氣 A/B/C/D
function chooseTone(){
  // affection 範圍 -10..+10，越正→越溺愛/賣萌（C/D），越負→越毒舌（B）
  const a = state.persona && typeof state.persona.affection === 'number' ? state.persona.affection : 0;
  // 計算權重：基礎為 [A,B,C,D]，會依好感偏移
  // 我們把四種 tone 的基礎機率設為均等，然後根據 affection 調整
  // 方式：把 affection 映射到一個偏移值 -1..1
  const bias = Math.max(-1, Math.min(1, a / 10)); // -1..1
  // 當 bias < 0 時，偏向 B（毒舌），當 bias > 0 時，偏向 C、D（溫暖/害羞）
  // 產生權重
  let wA = 1.0;
  let wB = 1.0 + (-bias > 0 ? -bias * 1.5 : 0); // 好感低→B 增加
  let wC = 1.0 + (bias > 0 ? bias * 1.2 : 0);   // 好感高→C 增加
  let wD = 1.0 + (bias > 0 ? bias * 0.8 : 0);   // 好感高→D 略增

  // 輸出機率
  const list = [
    {k:'A', w: wA},
    {k:'B', w: wB},
    {k:'C', w: wC},
    {k:'D', w: wD}
  ];
  const total = list.reduce((s,i)=>s+i.w,0);
  let r = Math.random() * total;
  for(const it of list){
    r -= it.w;
    if(r <= 0) return it.k;
  }
  return 'A';
}

// ---------- memoryRules 載入（非阻塞） ----------
let memoryRules = null;
async function loadMemoryRules(){
  try{
    const res = await fetch('memory-rules.json');
    if(res.ok) {
      memoryRules = await res.json();
      console.log('memoryRules loaded:', memoryRules);
    } else {
      console.warn('memory-rules.json not found (status ' + res.status + ')');
    }
  }catch(err){
    console.warn('loadMemoryRules failed', err);
  }
}
// 立即啟動載入（非阻塞）
loadMemoryRules();
// ---------- memoryRules 載入結束 ----------
  
// 更新版 maidReply：會依據 chooseTone() 來抓對應的 pool 並回覆
async function maidReply(userMessage) {
  const text = (userMessage || '').toLowerCase();

  // 先根據語句判斷「情緒影響」：例如稱讚、罵人、撒嬌，會影響 affection
  // 這段可以擴充關鍵字
  const positiveTriggers = ['謝謝','感謝','你真棒','好厲害','愛你','喜歡你','厲害'];
  const negativeTriggers = ['笨','蠢','白癡','討厭','爛','幹','去死'];

  for(const p of positiveTriggers){
    if(text.includes(p)) { adjustAffection(+2); break; }
  }
  for(const n of negativeTriggers){
    if(text.includes(n)) { adjustAffection(-2); break; }
  }

  // 決定 category（語意分類）跟 tone（A/B/C/D）
  let category = 'fallback';
  if (text.includes('你好') || text.includes('嗨') || text.includes('哈囉')) category = 'greeting';
  else if (text.includes('喜歡我') || text.includes('愛我') || text.includes('喜歡你')) category = 'love';
  else if (text.includes('笑話') || text.includes('梗') || text.includes('好笑')) category = 'joke';
  else if (text.includes('1+1') || text.includes('1 + 1') || text.includes('1+ 1') || /幾/.test(text) ) {
    // 保留數學等簡單判斷可落回 generateResponse，如果需要可以擴充
    category = 'fallback';
  } else if (text.includes('你叫') || text.includes('名字')) {
    category = 'greeting';
  } else {
    // keep fallback
  }

  // 決定 tone
  const tone = chooseTone(); // 'A'|'B'|'C'|'D'

  // 從 personalityData 裡拿對應的陣列（如果你已用我們的四分法）
  let pool = [];

  // 支援兩種 personalityData 結構：
  // - 若 category 對應到物件 {A:[],B:[],C:[],D:[]} 使用 tone 池
  // - 若 category 對應到陣列（舊版）則直接用那個陣列
  const catData = personalityData[category];
  if(Array.isArray(catData)){
    pool = catData;
  } else if(catData && typeof catData === 'object' && catData[tone]){
    pool = catData[tone];
  } else {
    // fallback 保底
    const fallback = personalityData['fallback'];
    if(Array.isArray(fallback)) pool = fallback;
    else if(fallback && fallback[tone]) pool = fallback[tone];
  }

  // 若 pool 為空，嘗試 fallback 的 tone 池
  if(!pool || pool.length === 0){
    const fb = personalityData['fallback'];
    pool = Array.isArray(fb) ? fb : (fb && fb[tone] ? fb[tone] : ['人家現在沒話要說。']);
  }

  // 隨機取一則回覆
  const reply = pool[Math.floor(Math.random() * pool.length)];

  // 最後做小量的替換（例如把 %name% 換成使用者記憶內的名字）
  let finalReply = reply;
  const nameFact = state.memory.find(m=>m.key==='name');
  if(nameFact){
    finalReply = finalReply.replace(/%name%/g, nameFact.value);
  }

  return finalReply;
}
// ---------- 情緒 / 語氣系統 結束 ----------
// ---------- 新版結束 ----------

// UI bindings
document.getElementById('sendBtn').addEventListener('click', ()=>{
  const txt = document.getElementById('input').value;
  document.getElementById('input').value = '';
  userSend(txt);
});
document.getElementById('input').addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault();
    document.getElementById('sendBtn').click();
  }
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  if(confirm('確定要清除所有記憶與聊天紀錄嗎？（這動作不可逆）')) {
    state = { persona: defaultPersona, memory:[], history:[] };
    saveState();
    render();
  }
});

// 匯出 / 匯入
document.getElementById('exportBtn').addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'maid_memory.json'; a.click();
  URL.revokeObjectURL(url);
});
document.getElementById('importBtn').addEventListener('click', ()=>{
  document.getElementById('fileInput').click();
});
document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = (e)=>{
    try{
      const imported = JSON.parse(e.target.result);
      if(imported && imported.history && imported.memory){
        state = imported;
        saveState();
        render();
        alert('匯入成功！');
      } else alert('檔案格式好像不對。');
    }catch(err){ alert('解析失敗：'+err.message); }
  };
  r.readAsText(f);
});

// 初始化
loadState();
if(state.history.length === 0){
  state.history.push({role:'maid', text: state.persona.greeting});
  saveState();
}
render();
</script>
</body>
</html>
